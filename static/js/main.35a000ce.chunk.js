(this.webpackJsonpalgovisualization=this.webpackJsonpalgovisualization||[]).push([[0],{18:function(e,t,r){},43:function(e,t,r){},44:function(e,t,r){},46:function(e,t,r){},53:function(e,t,r){},54:function(e,t,r){},55:function(e,t,r){},56:function(e,t,r){},57:function(e,t,r){},58:function(e,t,r){},59:function(e,t,r){},61:function(e,t,r){"use strict";r.r(t);var n=r(1),a=r.n(n),i=r(15),s=r.n(i),c=(r(43),r(13)),l=(r(44),r(45),r(66)),o=r(67),h=r(68),d=(r(46),r(0)),j=function(e){var t=function(t){e.setSize(parseInt(t.target.dataset.number))};return Object(d.jsx)("div",{children:Object(d.jsxs)(o.a,{bg:"light",variant:"light",expand:"lg",className:"disabled",children:[Object(d.jsx)(o.a.Brand,{children:"Algo Visualization"}),Object(d.jsx)(o.a.Toggle,{"aria-controls":"basic-navbar-nav"}),Object(d.jsx)(o.a.Collapse,{id:"basic-navbar-nav",children:Object(d.jsxs)(h.a,{className:"ml-auto",children:[Object(d.jsxs)(l.a,{className:"mr-4",onClick:function(){e.setSort()},title:"Sorting Algos",id:"basic-nav-dropdown",children:[Object(d.jsx)(l.a.Item,{onClick:e.selectedAlgo,children:"Bubble "}),Object(d.jsx)(l.a.Divider,{}),Object(d.jsx)(l.a.Item,{onClick:e.selectedAlgo,children:"Selection "}),Object(d.jsx)(l.a.Divider,{}),Object(d.jsx)(l.a.Item,{onClick:e.selectedAlgo,children:"Insertion "}),Object(d.jsx)(l.a.Divider,{}),Object(d.jsx)(l.a.Item,{onClick:e.selectedAlgo,children:"Merge "}),Object(d.jsx)(l.a.Divider,{}),Object(d.jsx)(l.a.Item,{onClick:e.selectedAlgo,children:"Quick "}),Object(d.jsx)(l.a.Divider,{}),Object(d.jsx)(l.a.Item,{onClick:e.selectedAlgo,children:"Heap "})]}),function(){if(e.sortSelect)return Object(d.jsxs)(l.a,{className:"mr-4",title:"Array Size:  "+e.size,id:"basic-nav-dropdown",children:[Object(d.jsx)(l.a.Item,{"data-number":10,onClick:t,children:"10"}),Object(d.jsx)(l.a.Divider,{}),Object(d.jsx)(l.a.Item,{"data-number":20,onClick:t,children:"20"}),Object(d.jsx)(l.a.Divider,{}),Object(d.jsx)(l.a.Item,{"data-number":50,onClick:t,children:"50"}),Object(d.jsx)(l.a.Divider,{}),Object(d.jsx)(l.a.Item,{"data-number":100,onClick:t,children:"100"}),Object(d.jsx)(l.a.Divider,{}),Object(d.jsx)(l.a.Item,{"data-number":200,onClick:t,children:"200"})]})}()]})})]})})},u=(r(53),r(6)),b=(r(54),r(26)),f=(r(55),function(e){var t=e.width,r=e.height,n=e.val,a=e.stateA,i=e.stateB,s=e.stateC,c=e.stateD,l=e.sorted,o=e.style,h="Bar";l&&(h+=" Bar_sorted"),c?h+=" Bar_stateD":s?h+=" Bar_stateC":i?h+=" Bar_stateB":a&&(h+=" Bar_stateA");var j=Object(b.a)(Object(b.a)({},o),{},{width:"".concat(t,"%"),height:"".concat(r,"%")});return(a||i||s||c)&&(j.marginRight="".concat(.3*t,"%"),j.marginLeft="".concat(.3*t,"%")),Object(d.jsx)("div",{style:j,className:h,children:Object(d.jsx)("span",{children:n})})});var m=function(e){return Object(d.jsx)("div",{className:"Chart",children:function(){if(!e.visState)return null;var t=Math.max.apply(Math,Object(u.a)(e.visState.array)),r=e.visState.array;return r.map((function(n,a){var i=100/r.length,s=n/t*100,c=a===r.length?"0":i>3?"0.5rem":"0.125rem",l=e.visState.stateA.includes(a),o=e.visState.stateB.includes(a),h=e.visState.stateC.includes(a),j=e.visState.stateD.includes(a),u=e.visState.sortedIndexes.includes(a);return Object(d.jsx)(f,{val:i>=5?n:null,width:i,height:s,style:{marginRight:"".concat(c)},stateA:l,stateB:o,stateC:h,stateD:j,sorted:u},a)}))}()})},p=r(22);r(56);function x(e){var t=function(){return e.speedSelectStatus?"disabled":"enabled"},r=function(r){"disabled"!==t()&&e.speedSelect(r)};return Object(d.jsxs)("div",{className:"VisControls",children:[Object(d.jsx)(p.c,{onClick:function(){e.pickedAlgo&&e.repeat()},className:"button repeat-button repeat-button-".concat(e.pickedAlgo?"enabled":"disabled")}),Object(d.jsx)(p.e,{onClick:function(){e.backwardStatus&&e.backward()},className:"button increment-button backward-".concat(e.backwardStatus?"enabled":"disabled")}),e.playing?Object(d.jsx)(p.a,{onClick:function(){e.pause()},color:"#ff94c2",className:"button"}):Object(d.jsx)(p.b,{onClick:function(){e.playDisabled||(-1===e.step?e.play():e.resume())},className:"button button-".concat(e.playDisabled?"disabled":"enabled")}),Object(d.jsx)(p.d,{onClick:function(){e.forwardStatus&&e.forward()},className:"button increment-button forward-".concat(e.forwardStatus?"enabled":"disabled")}),Object(d.jsxs)("div",{className:"dropdown",children:[Object(d.jsxs)("button",{className:"dropbtn dropbtn-".concat(t()),children:[e.currentSpeed,"x"]}),Object(d.jsxs)("div",{className:"dropdown-content",children:[Object(d.jsx)("a",{onClick:r,children:"0.25x"}),Object(d.jsx)("a",{onClick:r,children:"0.5x"}),Object(d.jsx)("a",{onClick:r,children:"1x"}),Object(d.jsx)("a",{onClick:r,children:"2x"}),Object(d.jsx)("a",{onClick:r,children:"4x"})]})]})]})}r(57);var O=function(e){var t=e.progress;return console.log("progress in progress bar",t),Object(d.jsx)("div",{className:"ProgressBar",children:Object(d.jsx)("div",{className:"ProgressBar_Active",style:{width:"".concat(t,"%")}})})};var g=function(e){return console.log("props in VisualArea",e.data),Object(d.jsxs)("div",{className:"VisualWindow",children:[Object(d.jsx)(m,{visState:e.data}),Object(d.jsx)(O,{width:e.width,progress:e.progress})]})};r(58);function v(e){console.log(e);var t=function(){return Object(d.jsxs)("div",{className:"Info",children:[Object(d.jsx)("hr",{}),Object(d.jsx)("h2",{children:e.selectedAlgo+" Sort"}),Object(d.jsxs)("div",{className:"InfoBody",children:[Object(d.jsxs)("div",{className:"Description",children:["Quick Sort(link) is an in-place, Divide and Conqur sorting algorithm.  It picks an element as pivot and partitions the given array around the picked pivot.  After the partition step, the elements smaller than the pivot lies to the left and the elements greater than the pivot lies to the right.  Therefore, after the partitioning step, the pivot is in the correct spot.  The steps of the quickSort is summarized as follows:",Object(d.jsxs)("ol",{children:[Object(d.jsx)("li",{children:"Pick a pivot element (demo code picks the end)."}),Object(d.jsx)("li",{children:"Partitioning: all elements with values less than pivot come before, while all elements with values greater than pivot come after.  The mechanic is simple.  We have indexes i and j.  Index i points at an element that is one before the element that is greater than the pivot.  Index j is the traversing index.  When element at index j is smaller than the pivot, we increment index i by 1 and swap elements are index i and j, keeping all elements smaller than pivot on the left and all elements greater than pivot on the right."}),Object(d.jsx)("li",{children:"Recursively apply the above steps to the left half and right half of the subarrays."})]})]}),Object(d.jsxs)("div",{className:"Complexity",children:[Object(d.jsx)("h4",{children:"Performance"}),Object(d.jsx)("p",{children:"Space Complexity is O(1) because of the in-place nature of the algorithm."}),Object(d.jsx)("p",{children:"Time Complexity:"}),Object(d.jsxs)("ul",{children:[Object(d.jsx)("li",{children:"Worst-case: O(n^2), occurs when the array is already sorted.  If the array is already sorted, and we always pick the last element as pivot, then each recursive call processes an array of size one less than the previous list.  Consequently, we have a partial sum of (n-i) for i=0 to n, which is a O(n^2) algorithm."}),Object(d.jsx)("li",{children:"Best-case: O(n * log n), occurs when the partition divide the list into two equal pieces.  Then we have a call tree that is of height log(n) and on each level, we do n work.  "}),Object(d.jsx)("li",{children:"Average-case: O(n * log n), this can be derived from its recurrence relations of its best and worst case and applying master theorem for divide and conquer. "})]})]})]})]})},r=function(){return Object(d.jsxs)("div",{className:"Info",children:[Object(d.jsx)("hr",{}),Object(d.jsx)("h2",{children:e.selectedAlgo+" Sort"}),Object(d.jsxs)("div",{className:"InfoBody",children:[Object(d.jsxs)("div",{className:"Description",children:["Selection Sort sorts the array by repeatedly finding the minimium element from the unsorted part and putting it at the beginning.  The steps of the algorithm can be summarized as follows:",Object(d.jsxs)("ol",{children:[Object(d.jsx)("li",{children:"Iterate through the array, find the smallest element and swap it with the first element."}),Object(d.jsx)("li",{children:"Repeat the previous step to find the second smallest and so on until the array is sorted."})]})]}),Object(d.jsxs)("div",{className:"Complexity",children:[Object(d.jsx)("h4",{children:"Performance"}),Object(d.jsx)("p",{children:"Space Complexity is O(1) because of the in-place nature of the algorithm."}),Object(d.jsx)("p",{children:"Time Complexity:"}),Object(d.jsx)("ul",{children:Object(d.jsx)("li",{children:"O(n^2) is the time complexity as there are two nested loops."})})]})]})]})},n=function(){return Object(d.jsxs)("div",{className:"Info",children:[Object(d.jsx)("hr",{}),Object(d.jsx)("h2",{children:e.selectedAlgo+" Sort"}),Object(d.jsxs)("div",{className:"InfoBody",children:[Object(d.jsx)("div",{className:"Description",children:"Bubble Sort works by repeatedly swapping the adjacent elements if they are in wrong order.  The pass through the array is repeated until the array is in sorted order."}),Object(d.jsxs)("div",{className:"Complexity",children:[Object(d.jsx)("h4",{children:"Performance"}),Object(d.jsx)("p",{children:"Space Complexity is O(1) because of the in-place nature of the algorithm."}),Object(d.jsx)("p",{children:"Time Complexity:"}),Object(d.jsxs)("ul",{children:[Object(d.jsx)("li",{children:"Worst-case is O(n^2) because of the nested loops.  This occurs when the array is reverse sorted"}),Object(d.jsx)("li",{children:"Best-case is O(n) and this occurs when the array is already sorted."})]})]})]})]})},a=function(){return Object(d.jsxs)("div",{className:"Info",children:[Object(d.jsx)("hr",{}),Object(d.jsx)("h2",{children:e.selectedAlgo+" Sort"}),Object(d.jsxs)("div",{className:"InfoBody",children:[Object(d.jsxs)("div",{className:"Description",children:["Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part.  The steps of the code can be summarized as follows:",Object(d.jsxs)("ol",{children:[Object(d.jsx)("li",{children:"Use an outer loop to iterate through the array using an index i."}),Object(d.jsx)("li",{children:"Use an inner loop and start an index j with an initial value of i."}),Object(d.jsx)("li",{children:"Move the value at j to the left(sorted) portion of the array, continously swapping elements if the value at j is less than the value at j-1.  When this step is finished, the value the algorithm attempts to insert originally lies in its correct location."})]})]}),Object(d.jsxs)("div",{className:"Complexity",children:[Object(d.jsx)("h4",{children:"Performance"}),Object(d.jsx)("p",{children:"Space Complexity is O(1) because of the in-place nature of the algorithm."}),Object(d.jsx)("p",{children:"Time Complexity:"}),Object(d.jsx)("ul",{children:Object(d.jsx)("li",{children:"O(n^2) is the time complexity as there are two nested loops."})})]})]})]})},i=function(){return Object(d.jsxs)("div",{className:"Info",children:[Object(d.jsx)("hr",{}),Object(d.jsx)("h2",{children:e.selectedAlgo+" Sort"}),Object(d.jsxs)("div",{className:"InfoBody",children:[Object(d.jsxs)("div",{className:"Description",children:["Merge Sort is a Divide and Conquer algorithm. It divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves. The merge() function is used for merging two halves. The merge(arr, l, m, r) is a key process that assumes that arr[l..m] and arr[m+1..r] are sorted and merges the two sorted sub-arrays into one.  The code to Merge Sort can be summerized as follows:",Object(d.jsxs)("ol",{children:[Object(d.jsx)("li",{children:"Find the mid point to divide the array: mid = left + (right-1)/2"}),Object(d.jsx)("li",{children:"Call mergeSort on the left half: mergeSort(arr, left, mid)"}),Object(d.jsx)("li",{children:"Call mergeSort on the right half: mergeSort(arr, mid+1, right)"}),Object(d.jsx)("li",{children:"Merge the two previously sorted halves by calling merge(arr, left, mid, right)"})]})]}),Object(d.jsxs)("div",{className:"Complexity",children:[Object(d.jsx)("h4",{children:"Performance"}),Object(d.jsx)("p",{children:"Space Complexity is O(1) because of the in-place nature of the algorithm."}),Object(d.jsx)("p",{children:"Time Complexity:"}),Object(d.jsx)("p",{children:"The algorithm divides the array into halves on each recursive calls.  Therefore, we have Log(n) number of levels and for each level, we do linear amount of work(merge).  So in total, it takes O(n Log n) time."})]})]})]})},s=function(){return Object(d.jsxs)("div",{className:"Info",children:[Object(d.jsx)("hr",{}),Object(d.jsx)("h2",{children:e.selectedAlgo+" Sort"}),Object(d.jsxs)("div",{className:"InfoBody",children:[Object(d.jsxs)("div",{className:"Description",children:["Heap sort is a comparison-based sorting technique based on Binary Heap data structure.  When given an arbitrary array, Heap Sort construct a Min/Max Heap by shifting the elements in the array so that a value in a parent node is smaller than the values in its two children nodes.  Then the order of the array comes by repeatedly removing the first element of the array and re-heapifying the array.  The steps of Heap Sort can be summarized as follows:",Object(d.jsxs)("ul",{children:[Object(d.jsx)("li",{children:"Build a min heap from the input array."}),Object(d.jsx)("li",{children:"The smallest item is stored at the root(first index of array) of the heap.  Replace it with the last item of the heap followed by reducing the size of the heap by 1."}),Object(d.jsx)("li",{children:"Re-heapify the root of the tree."}),Object(d.jsx)("li",{children:"Repeat the above two steps."})]})]}),Object(d.jsxs)("div",{className:"Complexity",children:[Object(d.jsx)("h4",{children:"Performance"}),Object(d.jsx)("p",{children:"Space Complexity is O(1) because of the in-place nature of the algorithm."}),Object(d.jsx)("p",{children:"Time Complexity:"}),Object(d.jsxs)("ul",{children:[Object(d.jsx)("li",{children:"Worst-case is O(n^2) because of the nested loops.  This occurs when the array is reverse sorted"}),Object(d.jsx)("li",{children:"Best-case is O(n) and this occurs when the array is already sorted."})]})]})]})]})},c=function(){switch(e.selectedAlgo){case"Quick":return Object(d.jsx)(t,{});case"Insertion":return Object(d.jsx)(a,{});case"Selection":return Object(d.jsx)(r,{});case"Merge":return Object(d.jsx)(i,{});case"Bubble":return Object(d.jsx)(n,{});case"Heap":return Object(d.jsx)(s,{});default:return Object(d.jsx)("h1",{children:"Please select an algorithm"})}};return Object(d.jsx)("div",{children:Object(d.jsx)(d.Fragment,{children:e.selectedAlgo?c():Object(d.jsxs)("div",{className:"Info",children:[Object(d.jsx)("hr",{}),Object(d.jsx)("h2",{children:"Select algorithm"}),Object(d.jsx)("p",{children:"You must select an algorithm before you can see its description and time/space performances. "})]})})})}var y=function(e){return[{array:Object(u.a)(e),stateA:[],stateB:[],stateC:[],stateD:[],sortedIndexes:[]}]},w=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[],i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:[];e.push({array:Object(u.a)(t),stateA:Object(u.a)(n),stateB:Object(u.a)(a),stateC:Object(u.a)(i),stateD:Object(u.a)(s),sortedIndexes:Object(u.a)(r)})},S=function(e,t,r){var n=e[t];e[t]=e[r],e[r]=n},k=function(e){return e[e.length-1].sortedIndexes},C=function(e,t){return Object(u.a)(Array(t-e).keys()).map((function(t){return t+e}))},N=function(e,t,r,n){return{stateA:e,stateB:t,stateC:r,stateD:n}},I=N("Comparing","Swapping"),A=function(e){for(var t=y(e),r=0;r<e.length-1;r++){for(var n=r,a=r+1;a<e.length;a++)w(t,e,k(t),[n,a]),e[a]<e[n]&&(w(t,e,k(t),[n],[a]),n=a,w(t,e,k(t),[n],[a]));w(t,e,k(t),[],[r,n]),S(e,r,n),w(t,e,[].concat(Object(u.a)(k(t)),[r]),[],[])}return w(t,e,[].concat(Object(u.a)(k(t)),[e.length-1])),t},B=N("Comparing","Swapping","Overwrite from memory"),T=function(e){for(var t=y(e),r=1;r<e.length;r++){var n=e[r],a=r;for(w(t,e,[],[r]);a>0&&e[a-1]>n;)w(t,e,[],[a],[a-1]),e[a]=e[a-1],a--,w(t,e,[],[],[a,a-1]);w(t,e,[],[],[],[a]),e[a]=n}return w(t,e,Object(u.a)(Array(e.length).keys())),t};var D=N("Comparing","Swapping",null,"Less than pivot"),z=function(e){var t=y(e);return function e(r,n,a){if(n>=a)return n===a&&w(t,r,[].concat(Object(u.a)(k(t)),[n])),null;var i=function(e,t,r){return Math.floor(Math.random()*(r-t)+t)}(0,n,a);w(t,r,k(t),[i]),S(r,n,i),w(t,r,k(t),[i]),i=function(e,r,n){var a=r+1,i=r+1;for(w(t,e,k(t),[r]);i<=n;)e[i]<e[r]&&(w(t,e,k(t),[r],[i],[],C(r+1,a)),S(e,a,i),w(t,e,k(t),[r],[a],[],C(r+1,a)),a+=1),i+=1;return w(t,e,k(t),[a-1],[],[],C(r,a-1)),S(e,r,a-1),w(t,e,k(t),[a-1],[],[],C(r,a-1)),a-1}(r,n,a),w(t,r,[].concat(Object(u.a)(k(t)),[i])),e(r,n,i-1),e(r,i+1,a)}(e,0,e.length-1),t};var M=N("Comparing","Swapping"),_=function(e){for(var t=y(e),r=0;r<e.length;r++){for(var n=0;n<e.length-r-1;n++)w(t,e,k(t),[n,n+1]),e[n]>e[n+1]&&(S(e,n,n+1),w(t,e,k(t),[],[n,n+1]));w(t,e,[].concat(Object(u.a)(k(t)),[e.length-1-r]))}return t};var K=N("Comparing","Swapping",null,"Heap Built"),P=function(e){var t=y(e),r=function r(n,a,i){var s=function(e){return 2*e+1}(a),c=function(e){return 2*e+2}(a);w(t,n,k(t),[a,s]);var l=s<i&&n[s]>e[a]?s:a;w(t,n,k(t),[l,c]),(l=c<i&&n[c]>n[l]?c:l)!=a&&(w(t,n,k(t),[],[a,l]),S(n,a,l),w(t,n,k(t),[],[a,l]),r(e,l,i))};return function(e){!function(e){for(var n=Math.floor(e.length/2),a=e.length,i=n;i>=0;i--)r(e,i,a);w(t,e,k(t),[],[],[],C(0,e.length))}(e);for(var n=e.length,a=e.length-1;a>0;a--)w(t,e,k(t),[],[0,a]),S(e,0,a),r(e,0,n-=1),w(t,e,k(t),[],[],[],C(0,n));w(t,e,[].concat(Object(u.a)(k(t)),[0]))}(e),t},E=N("Call Merge Sort",null,"Overwrite from axillary array"),H=function(e){var t=y(e);return function e(r,n,a){var i=a-n;if(i<2)return i<1?r:[r[n]];var s=Math.floor((n+a)/2);w(t,r,[],Object(u.a)(Array(s-n).keys()).map((function(e){return e+n}))),e(r,n,s),w(t,r,[],Object(u.a)(Array(a-s).keys()).map((function(e){return e+s}))),e(r,s,a),function(e,r,n,a){for(var i=e.slice(r,n),s=e.slice(n,a),c=0,l=0,o=0;c<i.length&&l<s.length;)i[c]<=s[l]?(w(t,e,[],[],[],[o+r]),e[o+r]=i[c],c++,w(t,e,[],[],[],[o+r])):(w(t,e,[],[],[],[o+r]),e[o+r]=s[l],l++,w(t,e,[],[],[],[o+r])),o++;for(;c<i.length;)w(t,e,[],[],[],[o+r]),e[o+r]=i[c],c++,o++,w(t,e,[],[],[],[o+r]);for(;l<s.length;)w(t,e,[],[],[],[o+r]),e[o+r]=s[l],l++,o++,w(t,e,[],[],[],[o+r]);i.length=0,s.length=0}(r,n,s,a)}(e,0,e.length),w(t,e,Object(u.a)(Array(e.length).keys())),t};r(59);function q(e){var t=Object(b.a)({},e.colorKey),r=t.stateA,n=t.stateB,a=t.stateC,i=t.stateD,s=r||n||a||i?Object(d.jsxs)("div",{className:"ColorKey_Item",children:[Object(d.jsx)("div",{className:"ColorKey_Box ColorKey_Sorted",children:" "}),Object(d.jsx)("span",{children:"Sorted"})]}):Object(d.jsx)("div",{className:"ColorKey_Item",children:Object(d.jsx)("div",{className:"",children:Object(d.jsx)("span",{children:"***select an algorithm to see color keys"})})}),c=r?Object(d.jsxs)("div",{className:"ColorKey_Item",children:[Object(d.jsx)("div",{className:"ColorKey_Box ColorKey_StateA"}),Object(d.jsx)("span",{className:"text",children:r})]}):null,l=n?Object(d.jsxs)("div",{className:"ColorKey_Item",children:[Object(d.jsx)("div",{className:"ColorKey_Box ColorKey_StateB"}),Object(d.jsx)("span",{children:n})]}):null,o=a?Object(d.jsxs)("div",{className:"ColorKey_Item",children:[Object(d.jsx)("div",{className:"ColorKey_Box ColorKey_StateC"}),Object(d.jsx)("span",{children:a})]}):null,h=i?Object(d.jsxs)("div",{className:"ColorKey_Item",children:[Object(d.jsx)("div",{className:"ColorKey_Box ColorKey_StateD"}),Object(d.jsx)("span",{children:i})]}):null;return Object(d.jsxs)("div",{className:"ColorKeys",children:[s,c,l,o,h]})}var R=r(10),W=r.n(R);r(18);var F=function(){return Object(n.useEffect)((function(){W.a.highlightAll()})),Object(d.jsxs)("div",{className:"codeBlock",children:[Object(d.jsx)("hr",{}),Object(d.jsx)("h3",{children:"Code:"}),Object(d.jsx)("pre",{children:Object(d.jsx)("code",{className:"language-javascript",children:"function selectionSort(arr) \n{\n  for (var i = 0; i < arr.length; i++)\n  {\n    let minIndex = i;\n    for (var j = i+1; j < arr.length; j++){\n      //find the minIndex for each iteration\n      if (arr[j] < arr[minIndex]){\n        minIndex = j;\n      }\n    }\n    //switch the current i value with the value in the minIndex\n    let temp = arr[i];\n    arr[i] = arr[minIndex];\n    arr[minIndex] = temp;\n  }\n}"})})]})};var L=function(e){return Object(n.useEffect)((function(){W.a.highlightAll()})),Object(d.jsxs)("div",{className:"codeBlock",children:[Object(d.jsx)("hr",{}),Object(d.jsx)("h3",{children:"Code:"}),Object(d.jsx)("pre",{children:Object(d.jsx)("code",{className:"language-javascript",children:"function insertionSort(arr, n) { \n  var i, key, j;  //key stores the value of the current index\n  for (i = 1; i < n; i++){ \n    key = arr[i]; \n    j = i - 1; \n    /* Move elements of arr[0..i-1], that are greater than \n    key one position to the right their current position */\n    while (j >= 0 && arr[j] > key){ \n      arr[j + 1] = arr[j]; \n      j = j - 1; \n    } \n    arr[j + 1] = key;  //key is now at its sorted position\n  } \n} "})})]})};var Q=function(){return Object(n.useEffect)((function(){W.a.highlightAll()})),Object(d.jsxs)("div",{className:"codeBlock",children:[Object(d.jsx)("hr",{}),Object(d.jsx)("h3",{children:"Code:"}),Object(d.jsx)("pre",{children:Object(d.jsx)("code",{className:"language-javascript",children:"function bubbleSort(arr) \n{\n  for (var i = 0; i < arr.length-1; i++)\n  {\n    //Compare indexes j and j+1 and move the larger of the two to the right\n    for (j = 0; j < arr.length - i - 1; j++){  \n      if (arr[j] > arr[j+1]){  \n        swap(arr, j, j+1);\n      }\n    }\n    //Since the larger of j and j+1 is always moved to the right, \n    //index j (before exiting of the for-loop) is the largest of the array\n  }\n}"})})]})};var V=function(){return Object(n.useEffect)((function(){W.a.highlightAll()})),Object(d.jsxs)("div",{className:"codeBlock",children:[Object(d.jsx)("hr",{}),Object(d.jsx)("h3",{children:"Code:"}),Object(d.jsx)("pre",{children:Object(d.jsx)("code",{className:"language-javascript",children:"function pickRandomPivot(arr, low, high){\n  let pivotIndex = Math.floor(Math.random()*(high-low+1)+low)\n  let temp = arr[pivotIndex];\n  arr[pivotIndex] = arr[high];\n  arr[high] = temp;\n}\n\nfunction partition(arr, low, high){\n  //pick a random pivot and switch that element with high\n  pickRandomPivot(arr, low, high);\n  let pivot = arr[high];  //set the pivot\n  //index of smaller element than pivot, initially it is set to be a trivial index\n  let i = (low -1);  \n  for (var j = low; j < high; j++){  //strictly less than because at the end, \n    //we found the proper spot for index high\n    if (arr[j] < pivot){\n      i++;\n      //switch the smaller element to the left side.\n      var temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp\n    }\n    \n  }\n  //move pivot to the correct spot:\n  var temp = arr[i+1];\n  arr[i+1] = arr[high];\n  arr[high] = temp;\n  return i+1;\n}\n\nfunction quickSort(arr, low, high){\n  if (low < high){\n    var pivot = partition(arr, low, high);\n    quickSort(arr, low, pivot-1);\n    quickSort(arr, pivot+1, high);\n  }\n}"})})]})};var J=function(){return Object(n.useEffect)((function(){W.a.highlightAll()})),Object(d.jsxs)("div",{className:"codeBlock",children:[Object(d.jsx)("hr",{}),Object(d.jsx)("h3",{children:"Code:"}),Object(d.jsx)("pre",{children:Object(d.jsx)("code",{className:"language-javascript",children:"function merge(arr, l, m, r){  //l is left index, m is \n  //m is calculated by m = l + (r-1)/2\n  //sizes of the two arrays:\n  var leftSize = new Array(m-l+1);  \n  var rightSize = new Array(r-m); \n  var left = new Array(leftSize);\n  var right = new Array(rightSize);\n  for (var i = 0; i < leftSize; i++){\n    left[i] = arr[l+i];\n  }\n  for (var j = 0; j<rightSize; j++){\n    right[j] = arr[1+m+j];  //copy the right half of arr\n  }\n  var i = 0;  \n  var j = 0;\n  var k = l; //initial index of merged subarray\n  while(i<leftSize && j < rightSize){\n    if (left[i] <= right[j]){\n      arr[k] = left[i];\n      i++;\n    }else {\n      arr[k] = right[j];\n      j++\n    }\n    k++;\n  }\n  while(i < leftSize){\n    arr[k] = left[i];\n    k++;\n    i++;\n  }\n  while(j < rightSize){\n    arr[k] = right[j];\n    j++;\n    k++;\n  }\n}\n\nfunction mergeSort(arr, l, r){\n  if (l >= r){\n    return;\n  }\n  var m = l + parseInt((r-l)/2);\n  mergeSort(arr, l, m);\n  mergeSort(arr, m+1, r);\n  merge(arr, l, m, r);\n}"})})]})};var U=function(){return Object(n.useEffect)((function(){W.a.highlightAll()})),Object(d.jsxs)("div",{className:"codeBlock",children:[Object(d.jsx)("hr",{}),Object(d.jsx)("h3",{children:"Code:"}),Object(d.jsx)("pre",{children:Object(d.jsx)("code",{className:"language-javascript",children:"//index i is the node of violation of the max-heap property\nfunction heapify(arr, n, i){\n  let largest = i;\n  let l = 2*i; //left child index\n  let r = 2*i+1; //right child index\n  if (l < n && arr[l] > arr[largest]){\n    largest = l;\n  }\n  if (r < n && arr[r] > arr[largest]){\n    largest = r;\n  }\n  if (i != largest){\n    let temp = arr[i];\n    arr[i] = arr[largest];\n    arr[largest] = temp;\n    heapify(arr, n, largest);\n  }\n}\n\nfunction heapSort(arr){\n  let length = arr.length;\n  //leaves are already max-heaps.  So start at 1 level above leaves.\n  for (let i = length/2-1; i>=0; i--){  \n    heapify(arr, length, i);\n  }\n  //Now arr is a max-heap, next we move the root to the last element and heapify 1 less element:\n  for (let i = length-1; i>0; i--){\n    //move largest to the end and run heapify.\n    let temp = arr[0];\n    arr[0] = arr[i];\n    arr[i] = temp;\n    //violation occurs at index 0 since this element was swapped\n    //also the size of the size is now i, since for each iteration, 1 element\n    //gets placed at the correct spot\n    heapify(arr, i, 0);\n  }\n}"})})]})};var Y=function(e){return Object(d.jsx)("div",{children:function(){switch(e.selectedAlgo){case"Quick":return Object(d.jsx)("div",{children:Object(d.jsx)(V,{})});case"Insertion":return Object(d.jsx)("div",{children:Object(d.jsx)(L,{})});case"Selection":return Object(d.jsx)("div",{children:Object(d.jsx)(F,{})});case"Merge":return Object(d.jsx)("div",{children:Object(d.jsx)(J,{})});case"Bubble":return Object(d.jsx)("div",{children:Object(d.jsx)(Q,{})});case"Heap":return Object(d.jsx)("div",{children:Object(d.jsx)(U,{})});default:return null}}()})};var G=function(){var e={Selection:I,Quick:D,Merge:E,Heap:K,Insertion:B,Bubble:M},t=Object(n.useState)(!0),r=Object(c.a)(t,2),a=r[0],i=r[1],s=Object(n.useState)(10),l=Object(c.a)(s,2),o=l[0],h=l[1],u=Object(n.useState)(null),b=Object(c.a)(u,2),f=b[0],m=b[1],p=Object(n.useState)(null),O=Object(c.a)(p,2),y=O[0],w=O[1],S=Object(n.useState)(null),k=Object(c.a)(S,2),C=k[0],N=k[1],R=Object(n.useState)(0),W=Object(c.a)(R,2),F=W[0],L=W[1],Q=Object(n.useState)([]),V=Object(c.a)(Q,2),J=V[0],U=V[1],G=Object(n.useState)(1),X=Object(c.a)(G,2),Z=X[0],$=X[1],ee=Object(n.useRef)(-1);console.log("here is algo actions",C);var te=function(e){var t=[],r=500/Z,n=e.length;e.forEach((function(e,a){var i=setTimeout((function(){m(e),ee.current=ee.current+1,L((ee.current+1)/n*100)}),r*a);t.push(i)}));var a=setTimeout((function(){re()}),n*r);t.push(a),U(t)},re=function(){J.forEach((function(e){clearTimeout(e)})),U([])},ne=function(e){return Array(e).fill(0).map((function(){return Math.floor(5*Math.random()*e)+1}))};Object(n.useEffect)((function(){var e;if(y){switch(y){case"Selection":e=A(ne(o));break;case"Insertion":e=T(ne(o));break;case"Bubble":e=_(ne(o));break;case"Quick":e=z(ne(o));break;case"Heap":e=P(ne(o));break;case"Merge":e=H(ne(o))}N(e),m(e[0])}}),[o,y]);var ae=e[y];return Object(d.jsxs)("div",{className:"App",children:[Object(d.jsx)(j,{fixed:"top",selectedAlgo:function(e){w(e.target.innerText),re(),ee.current=-1,L(0)},size:o,sortSelect:a,setSize:h,setSort:function(){i(!0)}}),Object(d.jsx)(g,{data:f,progress:F}),Object(d.jsx)(x,{currentSpeed:Z,speedSelectStatus:ee.current>=0,speedSelect:function(e){$(parseFloat(e.target.innerText.slice(0,-1)))},repeat:function(){J.forEach((function(e){clearTimeout(e)})),ee.current=-1,te(C)},playing:!!J&&J.length>0,play:function(){te(C)},resume:function(){var e=C.slice(ee.current);te(e)},pause:re,step:ee.current,playDisabled:!C||(C.length<=0||ee.current>=C.length-1),forward:function(){ee.current<C.length-1&&(ee.current=ee.current+1,m(C[ee.current]));var e=C.length;L((ee.current+1)/e*100)},backward:function(){ee.current>0&&ee.current<C.length-1&&(ee.current=ee.current-1,m(C[ee.current]));var e=C.length;L((ee.current-1)/e*100)},forwardStatus:!!C&&ee.current<C.length-1,backwardStatus:!!C&&(ee.current>0&&ee.current<C.length-1),pickedAlgo:!!y}),Object(d.jsx)(q,{colorKey:ae}),Object(d.jsx)(v,{selectedAlgo:y}),Object(d.jsx)(Y,{selectedAlgo:y})]})},X=function(e){e&&e instanceof Function&&r.e(3).then(r.bind(null,69)).then((function(t){var r=t.getCLS,n=t.getFID,a=t.getFCP,i=t.getLCP,s=t.getTTFB;r(e),n(e),a(e),i(e),s(e)}))};s.a.render(Object(d.jsx)(a.a.StrictMode,{children:Object(d.jsx)(G,{})}),document.getElementById("root")),X()}},[[61,1,2]]]);
//# sourceMappingURL=main.35a000ce.chunk.js.map